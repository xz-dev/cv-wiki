# 记忆清理记录

> 2026-02-04 - 将详细信息从 MCP Memory Service 卸载到本地 Wiki

---

## 清理策略

### 已卸载到 Wiki（不再保留详细记忆）

以下信息已完整保存在 wiki/ 目录中，AI 应直接读取文件而非查询记忆：

1. **PR详细列表**
   - 180+ 小项目PR的完整记录
   - 每个PR的问题描述、解决方案、代码示例
   - → 查看 `wiki/by-scale/small-projects.md` 等文件

2. **技术深度分析**
   - MCP文件锁的完整代码和测试
   - VirtIO GPU驱动的BSOD分析
   - distrobox的cgroup详解
   - → 查看 `wiki/deep-dive/` 目录

3. **年度贡献详情**
   - 每年的PR列表和时间线
   - → 查看 `wiki/by-year/` 目录

4. **项目代码分析**
   - distrobox-plus 代码结构（976行）
   - 其他个人项目的代码细节
   - → 查看 `wiki/personal-projects/` 目录

### 保留在记忆中（索引级别）

以下信息继续保留在 MCP Memory Service：

1. **Wiki 索引** ✅
   - Wiki 位置和结构
   - 文件清单和使用方法

2. **核心统计** ✅
   - 200+ PRs, 100+ 项目
   - 120k+ Stars, 9年贡献

3. **方法论技能** ✅
   - 如何分析GitHub贡献
   - 可复用的工作流程

4. **重点项目摘要** ✅
   - 项目名称和Stars
   - 一句话描述
   - （详细内容见wiki）

---

## 为什么这样设计？

### 优势

1. **减少记忆冗余**
   - 避免重复存储详细信息
   - 记忆系统保持轻量

2. **便于维护更新**
   - Wiki 可以用 git 追踪变更
   - 支持协作编辑

3. **提高检索效率**
   - 文件系统搜索更快（grep）
   - 结构化目录更清晰

4. **适应不同 AI**
   - 简单AI：读取markdown
   - 高级AI：使用HOW_TO_ANALYZE.md

### 工作流程

```
用户提问 → AI检查记忆索引 → 发现在wiki中 → 读取文件 → 返回答案
          ↓ （如果不在wiki）
          检索详细记忆 → 返回答案
```

---

## 使用示例

### ❌ 错误方式
```
AI: 让我检索记忆中关于 MCP Servers PR #3286 的详细信息...
（记忆中只有索引，没有详细内容）
```

### ✅ 正确方式
```
AI: 我看到这个PR在 wiki/by-scale/mega-projects.md 中有详细记录
AI: 让我读取这个文件...
（直接读取文件获取完整内容）
```

---

## 检查清单

AI 处理 xz-dev 开源贡献相关问题时：

- [ ] 先查看记忆索引（wiki位置）
- [ ] 判断信息是否在wiki中
- [ ] 如果在wiki：直接读取文件
- [ ] 如果不在：查询详细记忆
- [ ] 返回答案时引用来源（wiki路径或记忆hash）

---

**清理时间**: 2026-02-04  
**Wiki 版本**: v1.0  
**记忆状态**: ✅ 已优化
